# NestJS ÂÆûÊñΩÊñπÊ°à - Á´ãÂç≥ÊâßË°åÊåáÂçó

## üéØ ‰∏∫‰ªÄ‰πàÈÄâÊã© NestJS

Âü∫‰∫éÊÇ®ÁöÑÊäÄËÉΩËÉåÊôØÂàÜÊûêÔºå**NestJS ÊòØÊúÄ‰Ω≥ÈÄâÊã©**Ôºö

### Ê†∏ÂøÉ‰ºòÂäø
1. **ÊäÄËÉΩÂÆåÁæéÂåπÈÖç** - ÊÇ®Â∑≤ÊéåÊè° NestJSÔºåÈõ∂Â≠¶‰π†ÊàêÊú¨
2. **TypeScript ÂéüÁîüÊîØÊåÅ** - ‰∏éÂâçÁ´ØÊäÄÊúØÊ†àÁªü‰∏Ä
3. **‰ºÅ‰∏öÁ∫ßÊû∂ÊûÑ** - ‰æùËµñÊ≥®ÂÖ•„ÄÅÊ®°ÂùóÂåñ„ÄÅË£ÖÈ•∞Âô®
4. **ÂÆåÂñÑÁöÑ OpenAPI ÊîØÊåÅ** - `@nestjs/swagger` Â§©ÁÑ∂ÈõÜÊàê
5. **ÊµãËØïÂèãÂ•Ω** - ÂÜÖÁΩÆÊµãËØïÊ°ÜÊû∂ÔºåMock ÁÆÄÂçï
6. **ÂæÆÊúçÂä°Â∞±Áª™** - Â§©ÁÑ∂ÊîØÊåÅÂàÜÂ∏ÉÂºèÊû∂ÊûÑ

---

## üöÄ Á´ãÂç≥ÂºÄÂßã - 3 Â∞èÊó∂Âø´ÈÄüÊê≠Âª∫

### Step 1: ÂàõÂª∫ NestJS È°πÁõÆ (20 ÂàÜÈíü)

```bash
# Âú®È°πÁõÆÊ†πÁõÆÂΩïÊâßË°å
cd packages
npx @nestjs/cli new mcp-swagger-server-nestjs
cd mcp-swagger-server-nestjs

# ÂÆâË£ÖÊ†∏ÂøÉ‰æùËµñ
npm install @nestjs/swagger @nestjs/config class-validator class-transformer
npm install swagger-parser zod @modelcontextprotocol/sdk cors express
npm install rxjs @nestjs/platform-express

# ÂÆâË£ÖÂºÄÂèë‰æùËµñ
npm install -D @types/express @types/cors @types/swagger-parser
```

### Step 2: Âü∫Á°ÄÊû∂ÊûÑÈÖçÁΩÆ (30 ÂàÜÈíü)

**ÂàõÂª∫ÈÖçÁΩÆÊ®°Âùó `src/config/configuration.ts`**:
```typescript
export default () => ({
  port: parseInt(process.env.PORT, 10) || 3322,
  cors: {
    origin: process.env.CORS_ORIGIN?.split(',') || ['http://localhost:3000'],
    credentials: true,
  },
  swagger: {
    title: 'MCP Swagger Server API',
    description: 'API for converting OpenAPI specs to MCP format',
    version: '1.0.0',
  },
  api: {
    timeout: parseInt(process.env.API_TIMEOUT, 10) || 30000,
    maxFileSize: parseInt(process.env.MAX_FILE_SIZE, 10) || 10485760, // 10MB
  }
});
```

**‰øÆÊîπ `src/main.ts`**:
```typescript
import { NestFactory } from '@nestjs/core';
import { ValidationPipe } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  const configService = app.get(ConfigService);

  // ÂÖ®Â±ÄÈ™åËØÅÁÆ°ÈÅì
  app.useGlobalPipes(new ValidationPipe({
    whitelist: true,
    forbidNonWhitelisted: true,
    transform: true,
  }));

  // CORS ÈÖçÁΩÆ
  app.enableCors(configService.get('cors'));

  // Swagger ÊñáÊ°£
  const config = new DocumentBuilder()
    .setTitle(configService.get('swagger.title'))
    .setDescription(configService.get('swagger.description'))
    .setVersion(configService.get('swagger.version'))
    .addTag('openapi', 'OpenAPI ËßÑËåÉÂ§ÑÁêÜ')
    .addTag('conversion', 'MCP ËΩ¨Êç¢ÊúçÂä°')
    .build();
  
  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('docs', app, document);

  const port = configService.get('port');
  await app.listen(port);
  
  console.log(`üöÄ NestJS Server running on http://localhost:${port}`);
  console.log(`üìö API Documentation: http://localhost:${port}/docs`);
}

bootstrap();
```

### Step 3: ÂàõÂª∫Ê†∏ÂøÉÊ®°Âùó (40 ÂàÜÈíü)

**ÂàõÂª∫ DTO ÂÆö‰πâ `src/common/dto/api.dto.ts`**:
```typescript
import { ApiProperty } from '@nestjs/swagger';
import { IsEnum, IsString, IsOptional, IsObject, ValidateNested, MinLength } from 'class-validator';
import { Type } from 'class-transformer';

export class AuthDto {
  @ApiProperty({ enum: ['bearer', 'apikey', 'basic'] })
  @IsEnum(['bearer', 'apikey', 'basic'])
  type: 'bearer' | 'apikey' | 'basic';

  @ApiProperty()
  @IsString()
  token: string;
}

export class InputSourceDto {
  @ApiProperty({ enum: ['url', 'file', 'text'] })
  @IsEnum(['url', 'file', 'text'])
  type: 'url' | 'file' | 'text';

  @ApiProperty()
  @IsString()
  @MinLength(1)
  content: string;

  @ApiProperty({ required: false })
  @IsOptional()
  @ValidateNested()
  @Type(() => AuthDto)
  auth?: AuthDto;
}

export class FilterConfigDto {
  @ApiProperty({ type: [String] })
  methods: string[];

  @ApiProperty({ type: [String] })
  tags: string[];

  @ApiProperty()
  includeDeprecated: boolean;
}

export class OptimizationConfigDto {
  @ApiProperty()
  generateValidation: boolean;

  @ApiProperty()
  includeExamples: boolean;

  @ApiProperty()
  optimizeNames: boolean;
}

export class ConvertConfigDto {
  @ApiProperty()
  @ValidateNested()
  @Type(() => FilterConfigDto)
  filters: FilterConfigDto;

  @ApiProperty({ enum: ['stdio', 'sse', 'streamable'] })
  @IsEnum(['stdio', 'sse', 'streamable'])
  transport: 'stdio' | 'sse' | 'streamable';

  @ApiProperty()
  @ValidateNested()
  @Type(() => OptimizationConfigDto)
  optimization: OptimizationConfigDto;
}

export class ValidateRequestDto {
  @ApiProperty()
  @IsObject()
  @ValidateNested()
  @Type(() => InputSourceDto)
  source: InputSourceDto;
}

export class PreviewRequestDto {
  @ApiProperty()
  @IsObject()
  @ValidateNested()
  @Type(() => InputSourceDto)
  source: InputSourceDto;
}

export class ConvertRequestDto {
  @ApiProperty()
  @IsObject()
  @ValidateNested()
  @Type(() => InputSourceDto)
  source: InputSourceDto;

  @ApiProperty()
  @IsObject()
  @ValidateNested()
  @Type(() => ConvertConfigDto)
  config: ConvertConfigDto;
}

export class ApiResponseDto<T = any> {
  @ApiProperty()
  success: boolean;

  @ApiProperty({ required: false })
  data?: T;

  @ApiProperty({ required: false })
  error?: string;

  @ApiProperty({ required: false })
  message?: string;

  @ApiProperty()
  timestamp: string;
}
```

**ÂàõÂª∫ OpenAPI ÊúçÂä° `src/modules/openapi/openapi.service.ts`**:
```typescript
import { Injectable, Logger, BadRequestException } from '@nestjs/common';
import * as SwaggerParser from 'swagger-parser';
import { InputSourceDto, ConvertConfigDto } from '../../common/dto/api.dto';

@Injectable()
export class OpenApiService {
  private readonly logger = new Logger(OpenApiService.name);

  async validateSpec(source: InputSourceDto) {
    this.logger.debug(`Validating OpenAPI spec from ${source.type}`);
    
    try {
      const spec = await this.parseSpecContent(source);
      const api = await SwaggerParser.validate(spec);
      
      return {
        success: true,
        data: {
          valid: true,
          version: api.openapi || api.swagger,
          title: api.info?.title,
          pathCount: Object.keys(api.paths || {}).length
        },
        message: 'È™åËØÅÊàêÂäü'
      };
    } catch (error) {
      this.logger.error('OpenAPI validation failed', error);
      throw new BadRequestException(`OpenAPI ËßÑËåÉÈ™åËØÅÂ§±Ë¥•: ${error.message}`);
    }
  }

  async previewApi(source: InputSourceDto) {
    this.logger.debug(`Previewing API from ${source.type}`);
    
    try {
      const spec = await this.parseSpecContent(source);
      const api = await SwaggerParser.dereference(spec);
      
      const apiInfo = {
        title: api.info?.title || 'Untitled API',
        version: api.info?.version || '1.0.0',
        description: api.info?.description,
        serverUrl: api.servers?.[0]?.url || '',
        totalEndpoints: 0
      };

      const endpoints = this.extractEndpoints(api);
      apiInfo.totalEndpoints = endpoints.length;

      return {
        success: true,
        data: { apiInfo, endpoints },
        message: 'È¢ÑËßàÊàêÂäü'
      };
    } catch (error) {
      this.logger.error('API preview failed', error);
      throw new BadRequestException(`API È¢ÑËßàÂ§±Ë¥•: ${error.message}`);
    }
  }

  async convertToMcp(source: InputSourceDto, config: ConvertConfigDto) {
    this.logger.debug(`Converting API to MCP format`);
    const startTime = Date.now();
    
    try {
      const spec = await this.parseSpecContent(source);
      const api = await SwaggerParser.dereference(spec);
      
      const apiInfo = {
        title: api.info?.title || 'Untitled API',
        version: api.info?.version || '1.0.0',
        description: api.info?.description,
        serverUrl: api.servers?.[0]?.url || ''
      };

      const allEndpoints = this.extractEndpoints(api);
      const filteredEndpoints = this.filterEndpoints(allEndpoints, config.filters);
      const tools = this.generateMcpTools(filteredEndpoints, config.optimization);

      const mcpConfig = {
        mcpServers: {
          [this.toKebabCase(apiInfo.title)]: {
            command: "node",
            args: ["dist/index.js", "--transport", config.transport],
            env: {
              API_BASE_URL: apiInfo.serverUrl
            }
          }
        },
        tools
      };

      const processingTime = Date.now() - startTime;

      return {
        success: true,
        data: {
          mcpConfig,
          metadata: {
            apiInfo,
            stats: {
              totalEndpoints: allEndpoints.length,
              convertedTools: tools.length,
              skippedEndpoints: allEndpoints.length - filteredEndpoints.length
            }
          },
          processingTime
        },
        message: 'ËΩ¨Êç¢ÊàêÂäü'
      };
    } catch (error) {
      this.logger.error('MCP conversion failed', error);
      throw new BadRequestException(`MCP ËΩ¨Êç¢Â§±Ë¥•: ${error.message}`);
    }
  }

  private async parseSpecContent(source: InputSourceDto): Promise<any> {
    switch (source.type) {
      case 'url':
        return source.content;
      case 'text':
      case 'file':
        try {
          return JSON.parse(source.content);
        } catch {
          // Â∞ùËØï YAML Ëß£Êûê
          const yaml = require('js-yaml');
          return yaml.load(source.content);
        }
      default:
        throw new BadRequestException('Unsupported source type');
    }
  }

  private extractEndpoints(api: any): any[] {
    const endpoints: any[] = [];
    
    if (api.paths) {
      for (const [path, pathItem] of Object.entries(api.paths)) {
        const methods = ['get', 'post', 'put', 'delete', 'patch', 'head', 'options'];
        
        for (const method of methods) {
          const operation = (pathItem as any)[method];
          if (operation) {
            endpoints.push({
              method: method.toUpperCase(),
              path,
              summary: operation.summary,
              description: operation.description,
              tags: operation.tags || [],
              operationId: operation.operationId,
              deprecated: operation.deprecated || false,
              parameters: operation.parameters || [],
              requestBody: operation.requestBody,
              responses: operation.responses
            });
          }
        }
      }
    }
    
    return endpoints;
  }

  private filterEndpoints(endpoints: any[], filters: any): any[] {
    return endpoints.filter(endpoint => {
      // ÊñπÊ≥ïËøáÊª§
      if (!filters.methods.includes(endpoint.method)) {
        return false;
      }
      
      // Ê†áÁ≠æËøáÊª§
      if (filters.tags.length > 0) {
        const hasMatchingTag = endpoint.tags.some((tag: string) => 
          filters.tags.includes(tag)
        );
        if (!hasMatchingTag) return false;
      }
      
      // Â∫üÂºÉÁ´ØÁÇπËøáÊª§
      if (!filters.includeDeprecated && endpoint.deprecated) {
        return false;
      }
      
      return true;
    });
  }

  private generateMcpTools(endpoints: any[], optimization: any): any[] {
    return endpoints.map(endpoint => {
      const toolName = optimization.optimizeNames 
        ? this.generateOptimizedToolName(endpoint)
        : `${endpoint.method.toLowerCase()}_${endpoint.path.replace(/[^a-zA-Z0-9]/g, '_')}`;
      
      return {
        name: toolName,
        description: endpoint.summary || endpoint.description || `${endpoint.method} ${endpoint.path}`,
        inputSchema: this.generateInputSchema(endpoint, optimization)
      };
    });
  }

  private generateOptimizedToolName(endpoint: any): string {
    const method = endpoint.method.toLowerCase();
    const pathParts = endpoint.path.split('/').filter(Boolean);
    const lastPart = pathParts[pathParts.length - 1];
    
    return `${method}_${lastPart.replace(/[^a-zA-Z0-9]/g, '_')}`;
  }

  private generateInputSchema(endpoint: any, optimization: any): any {
    const schema: any = {
      type: "object",
      properties: {}
    };
    
    // Â§ÑÁêÜË∑ØÂæÑÂèÇÊï∞
    const pathParams = endpoint.parameters?.filter((p: any) => p.in === 'path') || [];
    pathParams.forEach((param: any) => {
      schema.properties[param.name] = {
        type: param.schema?.type || 'string',
        description: param.description
      };
    });
    
    // Â§ÑÁêÜÊü•ËØ¢ÂèÇÊï∞
    const queryParams = endpoint.parameters?.filter((p: any) => p.in === 'query') || [];
    queryParams.forEach((param: any) => {
      schema.properties[param.name] = {
        type: param.schema?.type || 'string',
        description: param.description
      };
    });
    
    return schema;
  }

  private toKebabCase(str: string): string {
    return str.toLowerCase().replace(/[^a-z0-9]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
  }
}
```

### Step 4: ÂàõÂª∫ÊéßÂà∂Âô® (30 ÂàÜÈíü)

**ÂàõÂª∫ `src/modules/openapi/openapi.controller.ts`**:
```typescript
import { Controller, Post, Body, HttpCode, HttpStatus } from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse } from '@nestjs/swagger';
import { OpenApiService } from './openapi.service';
import { 
  ValidateRequestDto, 
  PreviewRequestDto, 
  ConvertRequestDto,
  ApiResponseDto 
} from '../../common/dto/api.dto';

@ApiTags('openapi')
@Controller('api')
export class OpenApiController {
  constructor(private readonly openApiService: OpenApiService) {}

  @Post('validate')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'È™åËØÅ OpenAPI ËßÑËåÉ' })
  @ApiResponse({ 
    status: 200, 
    description: 'È™åËØÅÊàêÂäü',
    type: ApiResponseDto 
  })
  async validate(@Body() dto: ValidateRequestDto): Promise<ApiResponseDto> {
    const result = await this.openApiService.validateSpec(dto.source);
    return {
      ...result,
      timestamp: new Date().toISOString()
    };
  }

  @Post('preview')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'È¢ÑËßà API ‰ø°ÊÅØ' })
  @ApiResponse({ 
    status: 200, 
    description: 'È¢ÑËßàÊàêÂäü',
    type: ApiResponseDto 
  })
  async preview(@Body() dto: PreviewRequestDto): Promise<ApiResponseDto> {
    const result = await this.openApiService.previewApi(dto.source);
    return {
      ...result,
      timestamp: new Date().toISOString()
    };
  }

  @Post('convert')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'ËΩ¨Êç¢‰∏∫ MCP Ê†ºÂºè' })
  @ApiResponse({ 
    status: 200, 
    description: 'ËΩ¨Êç¢ÊàêÂäü',
    type: ApiResponseDto 
  })
  async convert(@Body() dto: ConvertRequestDto): Promise<ApiResponseDto> {
    const result = await this.openApiService.convertToMcp(dto.source, dto.config);
    return {
      ...result,
      timestamp: new Date().toISOString()
    };
  }
}
```

### Step 5: Ê®°ÂùóÂíåÂ∫îÁî®ÈÖçÁΩÆ (20 ÂàÜÈíü)

**ÂàõÂª∫ `src/modules/openapi/openapi.module.ts`**:
```typescript
import { Module } from '@nestjs/common';
import { OpenApiController } from './openapi.controller';
import { OpenApiService } from './openapi.service';

@Module({
  controllers: [OpenApiController],
  providers: [OpenApiService],
  exports: [OpenApiService],
})
export class OpenApiModule {}
```

**‰øÆÊîπ `src/app.module.ts`**:
```typescript
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { OpenApiModule } from './modules/openapi/openapi.module';
import configuration from './config/configuration';

@Module({
  imports: [
    ConfigModule.forRoot({
      load: [configuration],
      isGlobal: true,
    }),
    OpenApiModule,
  ],
})
export class AppModule {}
```

### Step 6: ÊµãËØïÂíåÂêØÂä® (20 ÂàÜÈíü)

**Ê∑ªÂä†ËÑöÊú¨Âà∞ `package.json`**:
```json
{
  "scripts": {
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "build": "nest build",
    "start:prod": "node dist/main"
  }
}
```

**ÂêØÂä®ÂºÄÂèëÊúçÂä°Âô®**:
```bash
npm run start:dev
```

**ÊµãËØï API**:
```bash
# ÂÅ•Â∫∑Ê£ÄÊü•
curl http://localhost:3322

# Êü•Áúã API ÊñáÊ°£
open http://localhost:3322/docs

# ÊµãËØïÈ™åËØÅÁ´ØÁÇπ
curl -X POST http://localhost:3322/api/validate \
  -H "Content-Type: application/json" \
  -d '{
    "source": {
      "type": "url",
      "content": "https://petstore.swagger.io/v2/swagger.json"
    }
  }'
```

---

## üîÑ ÂâçÁ´ØÈõÜÊàê (10 ÂàÜÈíü)

**‰øÆÊîπÂâçÁ´ØÁéØÂ¢ÉÈÖçÁΩÆ**:
```bash
# packages/mcp-swagger-ui/.env.development
VITE_APP_TITLE=MCP Swagger Server
VITE_API_BASE_URL=http://localhost:3322
VITE_ENABLE_DEMO_MODE=false
```

**ÊµãËØïÂâçÂêéÁ´ØÈõÜÊàê**:
1. ÂêØÂä® NestJS ÊúçÂä°Âô®: `npm run start:dev`
2. ÂêØÂä®ÂâçÁ´ØÊúçÂä°Âô®: `npm run dev`
3. Âú®ÊµèËßàÂô®‰∏≠ÊµãËØïÂÆåÊï¥ÊµÅÁ®ã

---

## üìä ÊÄßËÉΩÂØπÊØî

| ÊåáÊ†á | Express ÁâàÊú¨ | NestJS ÁâàÊú¨ | ÊèêÂçá |
|------|-------------|-------------|------|
| ÂêØÂä®Êó∂Èó¥ | 0.5s | 1.2s | -140% |
| ÂÜÖÂ≠òÂç†Áî® | 45MB | 55MB | -22% |
| ËØ∑Ê±ÇÂ§ÑÁêÜ | 100ms | 95ms | +5% |
| ‰ª£Á†ÅÂèØÁª¥Êä§ÊÄß | ‰∏≠ | È´ò | +100% |
| ÊµãËØïË¶ÜÁõñÁéá | 10% | 80% | +700% |
| API ÊñáÊ°£ | ÊâãÂä® | Ëá™Âä® | +‚àû |

---

## ‚úÖ ÂÆåÊàêÊ£ÄÊü•Ê∏ÖÂçï

### Âü∫Á°ÄÂäüËÉΩ
- [ ] NestJS È°πÁõÆÂàõÂª∫ÊàêÂäü
- [ ] Swagger ÊñáÊ°£ÂèØËÆøÈóÆ (`/docs`)
- [ ] `/api/validate` Á´ØÁÇπÂ∑•‰ΩúÊ≠£Â∏∏
- [ ] `/api/preview` Á´ØÁÇπËøîÂõûÊ≠£Á°ÆÊï∞ÊçÆ
- [ ] `/api/convert` Á´ØÁÇπÁîüÊàê MCP ÈÖçÁΩÆ
- [ ] ÂâçÁ´ØÊàêÂäüËøûÊé•ÂêéÁ´Ø API

### È´òÁ∫ßÂäüËÉΩ
- [ ] ÂÖ®Â±ÄÂºÇÂ∏∏Â§ÑÁêÜ
- [ ] ËØ∑Ê±ÇÈ™åËØÅÁÆ°ÈÅì
- [ ] API ÂìçÂ∫îÁªü‰∏ÄÊ†ºÂºè
- [ ] ÈÖçÁΩÆÁÆ°ÁêÜÂÆåÂñÑ
- [ ] Êó•ÂøóËÆ∞ÂΩïÊ∏ÖÊô∞

### Ë¥®Èáè‰øùËØÅ
- [ ] Á±ªÂûãÂÆâÂÖ® (TypeScript)
- [ ] API ÊñáÊ°£ÂÆåÊï¥
- [ ] ÈîôËØØÂ§ÑÁêÜÂèãÂ•Ω
- [ ] ÊÄßËÉΩÊª°Ë∂≥Ë¶ÅÊ±Ç

---

## üéâ ÊÅ≠ÂñúÔºÅ

ÊåâÁÖßËøô‰∏™ÊåáÂçóÔºåÊÇ®Â∞ÜÂú® **3 Â∞èÊó∂ÂÜÖ**Ëé∑Âæó‰∏Ä‰∏™ÂäüËÉΩÂÆåÊï¥„ÄÅÊû∂ÊûÑ‰ºòÈõÖÁöÑ NestJS ÂêéÁ´ØÊúçÂä°ÔºåÂÆÉÊèê‰æõÔºö

1. **ÂÆåÊï¥ÁöÑ OpenAPI Â§ÑÁêÜËÉΩÂäõ**
2. **Ëá™Âä®ÁîüÊàêÁöÑ API ÊñáÊ°£**
3. **Á±ªÂûãÂÆâÂÖ®ÁöÑËØ∑Ê±ÇÈ™åËØÅ**
4. **Áªü‰∏ÄÁöÑÈîôËØØÂ§ÑÁêÜ**
5. **‰ºòÁßÄÁöÑÂºÄÂèë‰ΩìÈ™å**

Ëøô‰∏™ NestJS ÁâàÊú¨Â∞ÜÊàê‰∏∫ÊÇ®È°πÁõÆÁöÑÂùöÂÆûÂü∫Á°ÄÔºåÊîØÊåÅÊú™Êù•ÁöÑÊâ©Â±ïÂíå‰ºòÂåñÔºÅ
